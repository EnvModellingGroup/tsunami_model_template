#!/usr/bin/env python

import numpy as np
import math
import sys

# Here, the symbols match the papers
# So some are copied form the common
# inside the block for each paper
# However, some might have to be switched around...

# Common for slide shape and behaviour
# Slide breadth - front-to-back
b = 686.0
# Slide width - side-to-side
w = 343.
# Slide max thickness
max_h = 24.
# start x-location
slide_start_x = 2137.773473+(b/2.)
# start y-location
slide_start_y = 0.0
# terminal velocity
ut = 21.09
# grav acceleration
g = 9.81
# angle of slide movement with resepct to X axis
eta = math.radians(0) 

# E&G
#-------------------------------------------------------------------------
# Enet, F. and Grilli, S. (2007) ‘Experimental Study of Tsunami Generation
# by Three-Dimensional Rigid Underwater Landslides’, Journal of Waterway, 
# Port, Coastal and Ocean Engineering, 133(6), pp. 442–454.
# and
# Ma, G., Kirby, J.T. and Shi, F. (2013) ‘Numerical simulation of tsunami 
# waves generated by deformable submarine landslides’, Ocean Modelling, 69(0), pp. 146–165.
eps = 0.717
C = math.acosh(1/eps)
kb = 2*C/b
kw = 2*C/w
a0 = 0.27
s0 = (ut*ut)/a0
t0 = ut/a0
y_centre = 0.0


# Harbitz
# --------------------------------------------------------------------
# Harbitz, C.B. (1992) ‘Model simulations of tsunamis generated by the 
# Storegga Slides’, Marine geology, 105(1-4), pp. 1–21.
U_max = ut
S = b/4.
L = b-S
B = w
Ra = 1000.
Rc = 0.
Rd = 1000.
R = Ra + Rc + Rd
T = (math.pi / 2.0) * ( R / U_max)
Ta = math.pi*Ra / (2.0 * U_max)
Tc = Rc / U_max
Td = math.pi*Rd / (2.0 * U_max)
k = 0.01
cd = (1.89 + 1.62*math.log10((L+S)/k))**(-5./2.)

# Sigmoidal distance function
# ---------------------------------
# Note this model need a longer run time to get 2000m runnout
ut_time = 175.
acc_scale =  24.
R = 2000.


def main():

    from scipy.interpolate import griddata
    import argparse
    import pylab
    import fileinput

    parser = argparse.ArgumentParser(
         prog="test slide function",
         description="""Test the prescribed slide function"""
    )
    parser.add_argument(
        '-v', 
        '--verbose', 
        action='store_true', 
        help="Verbose output: mainly progress reports.",
        default=False
    )

    parser.add_argument(
        '-t',
        '--time',
        type=float,
        default=100,
        help="Which time to use"
    )
    parser.add_argument(
        '-a',
        '--animation',
        type=float,
        default=0,
        help="Do animation of slide dynamics from 0 to time specified"
    )
    parser.add_argument(
        '--coords',
        metavar='coords',
        type = float,
        nargs = "+",
        help='List of coords on which to check the funciton'
    )

    args = parser.parse_args()
    verbose = args.verbose    
    coords = args.coords
    time = args.time
    anim = args.animation
    dt = 10
    x_coords = []
    vel = []
    if (coords == None):
        coords = np.arange(0,8000,10)

    for c in coords:
        x_coords.append([c,0.0])

    params = {
      'legend.fontsize': 18,
      'xtick.labelsize': 16,
      'ytick.labelsize': 16,
      'font.size' : 18,
      'axes.labelsize' : 18,
      'figure.subplot.hspace' : 0.5
    }
    pylab.rcParams.update(params)

    fig = pylab.figure(figsize=(15,8),dpi=90)
    ax = fig.add_subplot(111)  

    if (anim == 0):
        anim = time+1
        pylab.ioff()
    else:
        time = 0
        pylab.ion()
    for t in np.arange(time,anim,dt):
        vel = []
        h1 = []
        for c in x_coords:
            h1.append(slide_height(c,t))
        h2 = []
        for c in x_coords:
            h2.append(slide_height(c,t, form="harbitz",profile="harbitz"))
        h3 = []
        for c in x_coords:
            h3.append(slide_height(c,t,form="eg",profile="sigmoid"))

        pylab.plot(x_coords,h1)
        pylab.plot(x_coords,h2)
        pylab.plot(x_coords,h3)

        pylab.draw()
        
    if (anim == time + 1):
        pylab.show()

def set_slide_centre(t,profile="eg"):
    
    if (profile == "eg") :
        if t<= 0:
            t = 0
        centre = s0*math.log(math.cosh(t/t0))

        return centre

    elif (profile == "harbitz"):

        if t > T:
            t = T
        if t < 0:
            t = 0
        if t < Ta:
            s = Ra*(1-math.cos(U_max/Ra*t))
        elif Ta < t < Tc+Ta:
            s = Ra + U_max*(t - Ta)
        elif Ta+Tc < t < Ta+Tc+Td:
            s = Ra+Rc + Rd*math.sin(U_max/Rd * (t - Ta - Tc))
        else:
            s = R

        return s

    elif (profile == "sigmoid"):

        #sigmoid = (t-ut_time)/acc_scale
        #sigmoid = math.exp(-1.*((t-ut_time)/acc_scale))
        #/((1. + math.exp(-1*((t-ut_time)/acc_scale)))**2)
        #print(sigmoid, t)
        sigmoid = (math.exp((t-ut_time)/acc_scale)/(math.exp((t-ut_time)/acc_scale)+1))
        s = R*sigmoid

        return s

    else:
        print("I don't recognise the velocity profile specified")
        print("Should be one of 'eg', 'haribitz', 'sigmoid'")
        sys.exit(-1)

    return 0


def slide_height(X,t,form="eg",profile="eg"):

    s = set_slide_centre(t,profile)

    slx = slide_start_x
    if (profile == "harbitz"):
        slx += (L+2*S)/2.

    x_loc = slx + s*(math.cos(eta))
    y_loc = slide_start_y + s*(math.sin(eta))

    x_dash = (X[0] - x_loc)* math.cos(eta) + (X[1] - y_loc)*math.sin(eta)
    y_dash = -(X[0] - x_loc)* math.sin(eta) + (X[1] - y_loc)*math.cos(eta)

    if  (form == "eg"):
        
        h = max_h/(1-eps) * ((1/math.cosh(kb*x_dash))*(1/math.cosh(kw*y_dash))-eps)
        if h < 0:
            h = 0
        return h

    elif (form == "harbitz"):
       
        if (-(L+2*S)<x_dash<-(L+S)):
            h = math.exp(-(2*(x_dash+S+L)/S)**4-(2.*y_dash/B)**4)
        elif ( -(L+S)<=x_dash<-S):
            h = math.exp(-(2*y_dash/B)**4)
        elif (-S<=x_dash<0):
            h = math.exp(-(2*(x_dash+S)/S)**4-(2.*y_dash/B)**4)
        else:
            h = 0

        return h*max_h

    else:
        print("Didn't understand your slide form parameter")
        print("Should be either 'harbitz' or 'eg'")
        sys.exit(-1)

    return 0


if __name__ == "__main__":
    main()
